import http from 'node:http';
import type { Ctx } from './context';
import { router, append_route } from './router';
import fs from 'node:fs';
import { storeCtx, initCtx } from './context';
import path from 'node:path';
import formidable from 'formidable';
import action from './action';
import { makeId } from './utils';
export let staticVersion = makeId()
type MiddleWare = (ctx: Ctx, next: Function) => Promise<void>
type Config = {
    htmlErrorHandler?: (errMessage: string) => string,
    /** used when your server is behind a proxy server. Default: x-forwarded-for */
    proxyHeader?: string
}
export let appConfig: Config = {

}

let layout = (body: string) => {
    return `<!doctype html><html><head></head><body>${body}</body><html>`
}
let middlewares: MiddleWare[] = []

const static_age = process.env.NODE_ENV == 'production' ? 3600 : 604800
let append_css = ''

async function call_middleware(index: number, ctx: Ctx, route_handler: (...args: any) => any) {
    let nextFn
    try {
        if (index >= 0) {
            nextFn = async () => { await call_middleware(index - 1, ctx, route_handler) }
            await middlewares[index](ctx, nextFn)
        }
        else {
            await route_handler(ctx)
        }
    } catch (e) {
        throw e
    }
}

let app = {
    errorHandler: (ctx: Ctx, e: any) => {
        let message = ''
        if (typeof e == 'object') { // sys generated err
            if (process.env.NODE_ENV == 'development') {
                message = e.message + `\n ${e.stack}`
                console.error(message)
            }
            else {
                message = 'sys error'
            }
        }
        else if (typeof e == 'string') {
            message = e
        }
        if (ctx.req.method == 'POST') {
            // user error, generated by ctx.err()
            if (message.match(/^err:/)) {
                message = message.replace(/^err:/, '')
            }
            // system error
            else {
                console.log(e)
                message = 'system err'
            }
            ctx.json({ err: message })
        }
        else {
            // user error, generated by ctx.err()
            if (message.match(/^err:/)) {
                message = message.replace(/^err:/, '')
            }
            // system error
            else {
                if (process.env.NODE_ENV != 'development') {
                    message = 'system err'
                }
            }
            ctx.res.writeHead(200, {
                'Content-Type': 'text/html',
            });
            ctx.res.end(app.htmlErrorHandler(message))
        }
    },
    htmlErrorHandler: (message: string) => {
        return `<html><title>Error</title><body><pre>${message}</pre></body></html>`
    },
    use: (fn: MiddleWare) => {
        middlewares.unshift(fn)
    },
    listen: (port: number) => {
        load_pages()
        const server = http.createServer(async (req, res) => {
            let appended_elements = []
            // js
            if (req.url == `/main.${staticVersion}.js`) {
                fs.readFile(__dirname + '/frontless.js', function (error, content) {
                    res.writeHead(200, {
                        'Content-Type': 'text/javascript',
                        'Cache-Control': 'public, max-age=' + static_age
                    });
                    res.end(content, 'utf-8');
                })
                return
            }
            // css
            if (req.url == `/main.${staticVersion}.css`) {
                fs.readFile(__dirname + '/frontless.css', function (error, content) {
                    res.writeHead(200, {
                        'Content-Type': 'text/css',
                        'Cache-Control': 'public, max-age=' + static_age
                    });
                    if (error) {
                        res.end('/* error reading frontless.css */', 'utf-8');
                    }
                    else {
                        res.end(content + "\n/* appended css */\n" + append_css, 'utf-8');
                    }
                })
                return
            }
            // static
            if (req?.url?.match(/^\/static\/(.+)/)) {
                serve_static(req, res)
                return
            }
            let ctx = initCtx(req, res, layout, app.errorHandler)
            // get POST form data 
            if (req.method == 'POST') {
                const form = formidable({});
                try {
                    let [body, files] = await form.parse(req);
                    ctx.files = files
                    for (let k in body) {
                        let field = body[k]
                        if (Array.isArray(field)) {
                            if (k.match(/\[\]/)) {
                                ctx.body[k.replace('[]', '')] = field.map(f => f.trim())
                            }
                            else {
                                ctx.body[k] = field[0].trim()
                            }
                        }
                        else {
                            ctx.body[k] = field ?? ''
                        }
                    }
                } catch (err) {
                    console.error(err);
                    res.writeHead(400, { 'Content-Type': 'text/plain' });
                    res.end(String(err));
                    return;
                }
            }

            // route
            let page_handler: () => void
            if (req.url?.match(/\/action\/[\d\w_\-]+\/[\d\w_\-]+/)) {
                page_handler = action
            }
            else {
                let r = router(ctx)
                if (r.matched) {
                    page_handler = async () => {
                        try {
                            let res = await r.handler(ctx)
                            ctx.send(res)
                        } catch (e) {
                            throw e
                        }
                    }
                }
                else {
                    res.writeHead(404, {
                        'Content-Type': 'text/html',
                    });
                    res.end(app.htmlErrorHandler('path not found ' + req.url))
                    return
                }
            }

            storeCtx(ctx, async () => {
                try {
                    await call_middleware(middlewares.length - 1, ctx, page_handler)
                } catch (e) {
                    if (ctx._sys.isSent) {
                        return
                    }
                    app.errorHandler(ctx, e)
                }
            })

        });

        server.on('clientError', (err, socket) => {
            socket.end('HTTP/1.1 400 Bad Request\r\n\r\n');
        });
        server.listen(port);
        console.log(`listening on port ${port}`)
    }
}



export function load_pages(path = 'pages') {
    fs.readdirSync(process.cwd() + '/' + path).forEach(async function (filename) {
        let reletive_filepath = path + '/' + filename;
        let filepath = process.cwd() + '/' + reletive_filepath
        if (fs.lstatSync(filepath).isDirectory()) {
            load_pages(reletive_filepath)
        }
        else if (filename == '_layout.ts') {
            let render_ = await import(filepath)
            layout = render_.default
        }
        else if (filename == '_layout.css') {
            append_css = fs.readFileSync(filepath, { encoding: 'utf8', flag: 'r' })
        }
        else if (filename.match(/\.ts$/)) {
            append_route_from_file({ path: reletive_filepath, name: reletive_filepath })
        }
    })
}

async function append_route_from_file(file: { path: string, name: string }) {
    let route_path = file.path.replace(/\.js|\.ts$/, '').replace(/^pages\//, '')
    if (route_path == 'index') {
        route_path = ''
    }
    route_path = '/' + route_path
    let handler = await import(process.cwd() + '/' + file.path)
    append_route(route_path, handler.default)
}

function serve_static(req: http.IncomingMessage, res: http.ServerResponse) {
    let filePath = process.cwd() + req.url
    fs.readFile(filePath, function (error, content) {
        if (error) {
            res.writeHead(404);
            res.end('file not found')
        }
        else {
            var extname = path.extname(req.url ?? '');
            var contentType = 'unknown';
            switch (extname) {
                case '.html':
                    contentType = 'text/html';
                    break;
                case '.js':
                    contentType = 'text/javascript';
                    break;
                case '.css':
                    contentType = 'text/css';
                    break;
                case '.json':
                    contentType = 'application/json';
                    break;
                case '.png':
                    contentType = 'image/png';
                    break;
                case '.jpg':
                    contentType = 'image/jpg';
                    break;
                case '.wav':
                    contentType = 'audio/wav';
                    break;
                case '.svg':
                    contentType = 'image/svg+xml'
                    break;
            }
            res.writeHead(200, { 'Content-Type': contentType, 'Cache-Control': 'public, max-age=3600' });
            res.end(content, 'utf-8');
        }
    });
}


export default function Frontless(config: Config = {}) {
    if (typeof config.htmlErrorHandler == 'function') {
        app.htmlErrorHandler = config.htmlErrorHandler
    }
    appConfig = config
    return app
}

